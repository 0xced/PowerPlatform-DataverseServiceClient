using Microsoft.Crm.Sdk.Messages;
using Microsoft.Extensions.Caching.Memory;
using Microsoft.Xrm.Sdk;
using Microsoft.Xrm.Sdk.Messages;
using Microsoft.Xrm.Sdk.Query;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Xml;

namespace Microsoft.PowerPlatform.Dataverse.Client.Extensions
{
    /// <summary>
    /// Extentions to support query builder and untyped object returns. 
    /// </summary>
    public static class QueryExtensions
    {
        /// <summary>
        /// Gets a list of accounts based on the search parameters.
        /// </summary>
        /// <param name="entityName">Dataverse Entity Type Name to search</param>
        /// <param name="searchParameters">Array of Search Parameters</param>
        /// <param name="fieldList">List of fields to retrieve, Null indicates all Fields</param>
        /// <param name="searchOperator">Logical Search Operator</param>
        /// <param name="bypassPluginExecution">Adds the bypass plugin behavior to this request. Note: this will only apply if the caller has the prvBypassPlugins permission to bypass plugins.  If its attempted without the permission the request will fault.</param>
        /// <param name="batchId">Optional: if set to a valid GUID, generated by the Create Batch Request Method, will assigned the request to the batch for later execution, on fail, runs the request immediately </param>
        /// <param name="serviceClient">ServiceClient</param>
        /// <returns>List of matching Entity Types. </returns>

        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope = "member")]
        public static Dictionary<string, Dictionary<string, object>> GetEntityDataBySearchParams(this ServiceClient serviceClient,
            string entityName,
            Dictionary<string, string> searchParameters,
            LogicalSearchOperator searchOperator,
            List<string> fieldList,
            Guid batchId = default(Guid),
            bool bypassPluginExecution = false)
        {
            List<DataverseSearchFilter> searchList = new List<DataverseSearchFilter>();
            serviceClient.BuildSearchFilterListFromSearchTerms(searchParameters, searchList);

            string pgCookie = string.Empty;
            bool moreRec = false;
            return serviceClient.GetEntityDataBySearchParams(entityName, searchList, searchOperator, fieldList, null, -1, -1, string.Empty, out pgCookie, out moreRec, batchId, bypassPluginExecution: bypassPluginExecution);
        }


        /// <summary>
        /// Gets a list of accounts based on the search parameters.
        /// </summary>
        /// <param name="entityName">Dataverse Entity Type Name to search</param>
        /// <param name="searchParameters">Array of Search Parameters</param>
        /// <param name="fieldList">List of fields to retrieve, Null indicates all Fields</param>
        /// <param name="searchOperator">Logical Search Operator</param>
        /// <param name="batchId">Optional: if set to a valid GUID, generated by the Create Batch Request Method, will assigned the request to the batch for later execution, on fail, runs the request immediately </param>
		/// <param name="bypassPluginExecution">Adds the bypass plugin behavior to this request. Note: this will only apply if the caller has the prvBypassPlugins permission to bypass plugins.  If its attempted without the permission the request will fault.</param>
        /// <param name="serviceClient">ServiceClient</param>
        /// <returns>List of matching Entity Types. </returns>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope = "member")]
        public static Dictionary<string, Dictionary<string, object>> GetEntityDataBySearchParams(this ServiceClient serviceClient,
            string entityName,
            List<DataverseSearchFilter> searchParameters,
            LogicalSearchOperator searchOperator,
            List<string> fieldList, Guid batchId = default(Guid),
            bool bypassPluginExecution = false)
        {
            string pgCookie = string.Empty;
            bool moreRec = false;
            return serviceClient.GetEntityDataBySearchParams(entityName, searchParameters, searchOperator, fieldList, null, -1, -1, string.Empty, out pgCookie, out moreRec, batchId, bypassPluginExecution);
        }

        /// <summary>
        /// Searches for data from an entity based on the search parameters.
        /// </summary>
        /// <param name="entityName">Name of the entity to search </param>
        /// <param name="searchParameters">Array of Search Parameters</param>
        /// <param name="fieldList">List of fields to retrieve, Null indicates all Fields</param>
        /// <param name="searchOperator">Logical Search Operator</param>
        /// <param name="pageCount">Number records per Page</param>
        /// <param name="pageNumber">Current Page number</param>
        /// <param name="pageCookie">inbound place holder cookie</param>
        /// <param name="outPageCookie">outbound place holder cookie</param>
        /// <param name="isMoreRecords">is there more records or not</param>
        /// <param name="sortParameters">Sort order</param>
        /// <param name="batchId">Optional: if set to a valid GUID, generated by the Create Batch Request Method, will assigned the request to the batch for later execution, on fail, runs the request immediately </param>
		/// <param name="bypassPluginExecution">Adds the bypass plugin behavior to this request. Note: this will only apply if the caller has the prvBypassPlugins permission to bypass plugins.  If its attempted without the permission the request will fault.</param>
        /// <param name="serviceClient">ServiceClient</param>
        /// <returns>List of matching Entity Types. </returns>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Scope = "member")]
        public static Dictionary<string, Dictionary<string, object>> GetEntityDataBySearchParams(this ServiceClient serviceClient,
            string entityName,
            List<DataverseSearchFilter> searchParameters,
            LogicalSearchOperator searchOperator,
            List<string> fieldList,
            Dictionary<string, LogicalSortOrder> sortParameters,
            int pageCount,
            int pageNumber,
            string pageCookie,
            out string outPageCookie,
            out bool isMoreRecords,
            Guid batchId = default(Guid),
            bool bypassPluginExecution = false
            )
        {
            serviceClient._logEntry.ResetLastError();  // Reset Last Error

            outPageCookie = string.Empty;
            isMoreRecords = false;

            if (serviceClient.DataverseService == null)
            {
                serviceClient._logEntry.Log("Dataverse Service not initialized", TraceEventType.Error);
                return null;
            }

            if (searchParameters == null)
                searchParameters = new List<DataverseSearchFilter>();

            // Build the query here.
            QueryExpression query = BuildQueryFilter(entityName, searchParameters, fieldList, searchOperator);

            if (pageCount != -1)
            {
                PagingInfo pgInfo = new PagingInfo();
                pgInfo.Count = pageCount;
                pgInfo.PageNumber = pageNumber;
                pgInfo.PagingCookie = pageCookie;
                query.PageInfo = pgInfo;
            }

            if (sortParameters != null)
                if (sortParameters.Count > 0)
                {
                    List<OrderExpression> qExpressList = new List<OrderExpression>();
                    foreach (KeyValuePair<string, LogicalSortOrder> itm in sortParameters)
                    {
                        OrderExpression ordBy = new OrderExpression();
                        ordBy.AttributeName = itm.Key;
                        if (itm.Value == LogicalSortOrder.Ascending)
                            ordBy.OrderType = OrderType.Ascending;
                        else
                            ordBy.OrderType = OrderType.Descending;

                        qExpressList.Add(ordBy);
                    }

                    query.Orders.AddRange(qExpressList.ToArray());
                }


            RetrieveMultipleRequest retrieve = new RetrieveMultipleRequest();
            //retrieve.ReturnDynamicEntities = true;
            retrieve.Query = query;


            if (serviceClient.AddRequestToBatch(batchId, retrieve, "Running GetEntityDataBySearchParms", "Request For GetEntityDataBySearchParms Queued", bypassPluginExecution))
                return null;


            RetrieveMultipleResponse retrieved;
            retrieved = (RetrieveMultipleResponse)serviceClient.Command_Execute(retrieve, "GetEntityDataBySearchParms", bypassPluginExecution);
            if (retrieved != null)
            {
                outPageCookie = retrieved.EntityCollection.PagingCookie;
                isMoreRecords = retrieved.EntityCollection.MoreRecords;

                return CreateResultDataSet(retrieved.EntityCollection);
            }
            else
                return null;
        }


        /// <summary>
        /// Searches for data based on a FetchXML query
        /// </summary>
        /// <param name="fetchXml">Fetch XML query data.</param>
        /// <param name="batchId">Optional: if set to a valid GUID, generated by the Create Batch Request Method, will assigned the request to the batch for later execution, on fail, runs the request immediately </param>
        /// <param name="bypassPluginExecution">Adds the bypass plugin behavior to this request. Note: this will only apply if the caller has the prvBypassPlugins permission to bypass plugins.  If its attempted without the permission the request will fault.</param>
        /// <param name="serviceClient">ServiceClient</param>
        /// <returns>results or null</returns>
        public static Dictionary<string, Dictionary<string, object>> GetEntityDataByFetchSearch(this ServiceClient serviceClient, string fetchXml, Guid batchId = default(Guid), bool bypassPluginExecution = false)
        {
            EntityCollection ec = serviceClient.GetEntityDataByFetchSearchEC(fetchXml, batchId, bypassPluginExecution);
            if (ec != null)
                return CreateResultDataSet(ec);
            else
                return null;
        }


        /// <summary>
        /// Searches for data based on a FetchXML query
        /// </summary>
        /// <param name="fetchXml">Fetch XML query data.</param>
        /// <param name="batchId">Optional: if set to a valid GUID, generated by the Create Batch Request Method, will assigned the request to the batch for later execution, on fail, runs the request immediately </param>
        /// <param name="bypassPluginExecution">Adds the bypass plugin behavior to this request. Note: this will only apply if the caller has the prvBypassPlugins permission to bypass plugins.  If its attempted without the permission the request will fault.</param>
        /// <param name="serviceClient">ServiceClient</param>
        /// <returns>results as an entity collection or null</returns>
        public static EntityCollection GetEntityDataByFetchSearchEC(this ServiceClient serviceClient, string fetchXml, Guid batchId = default(Guid), bool bypassPluginExecution = false)
        {
            serviceClient._logEntry.ResetLastError();  // Reset Last Error

            if (serviceClient.DataverseService == null)
            {
                serviceClient._logEntry.Log("Dataverse Service not initialized", TraceEventType.Error);
                return null;
            }

            if (string.IsNullOrWhiteSpace(fetchXml))
                return null;

            // This model directly requests the via FetchXML
            RetrieveMultipleRequest req = new RetrieveMultipleRequest() { Query = new FetchExpression(fetchXml) };
            RetrieveMultipleResponse retrieved;

            if (serviceClient.AddRequestToBatch(batchId, req, "Running GetEntityDataByFetchSearchEC", "Request For GetEntityDataByFetchSearchEC Queued", bypassPluginExecution))
                return null;

            retrieved = (RetrieveMultipleResponse)serviceClient.Command_Execute(req, "GetEntityDataByFetchSearch - Direct", bypassPluginExecution);
            if (retrieved != null)
            {
                return retrieved.EntityCollection;
            }
            else
                return null;
        }

        /// <summary>
        /// Searches for data based on a FetchXML query
        /// </summary>
        /// <param name="fetchXml">Fetch XML query data.</param>
        /// <param name="pageCount">Number records per Page</param>
        /// <param name="pageNumber">Current Page number</param>
        /// <param name="pageCookie">inbound place holder cookie</param>
        /// <param name="outPageCookie">outbound place holder cookie</param>
        /// <param name="isMoreRecords">is there more records or not</param>
        /// <param name="bypassPluginExecution">Adds the bypass plugin behavior to this request. Note: this will only apply if the caller has the prvBypassPlugins permission to bypass plugins.  If its attempted without the permission the request will fault.</param>
        /// <param name="batchId">Optional: if set to a valid GUID, generated by the Create Batch Request Method, will assigned the request to the batch for later execution, on fail, runs the request immediately </param>
        /// <param name="serviceClient">ServiceClient</param>
        /// <returns>results or null</returns>
        public static Dictionary<string, Dictionary<string, object>> GetEntityDataByFetchSearch(this ServiceClient serviceClient,
                string fetchXml,
                int pageCount,
                int pageNumber,
                string pageCookie,
                out string outPageCookie,
                out bool isMoreRecords,
                Guid batchId = default(Guid),
                bool bypassPluginExecution = false)
        {
            EntityCollection ec = serviceClient.GetEntityDataByFetchSearchEC(fetchXml, pageCount, pageNumber, pageCookie, out outPageCookie, out isMoreRecords, bypassPluginExecution: bypassPluginExecution);
            if (ec != null)
                return CreateResultDataSet(ec);
            else
                return null;
        }

        /// <summary>
        /// Searches for data based on a FetchXML query
        /// </summary>
        /// <param name="fetchXml">Fetch XML query data.</param>
        /// <param name="pageCount">Number records per Page</param>
        /// <param name="pageNumber">Current Page number</param>
        /// <param name="pageCookie">inbound place holder cookie</param>
        /// <param name="outPageCookie">outbound place holder cookie</param>
        /// <param name="batchId">Optional: if set to a valid GUID, generated by the Create Batch Request Method, will assigned the request to the batch for later execution, on fail, runs the request immediately </param>
        /// <param name="bypassPluginExecution">Adds the bypass plugin behavior to this request. Note: this will only apply if the caller has the prvBypassPlugins permission to bypass plugins.  If its attempted without the permission the request will fault.</param>
        /// <param name="isMoreRecords">is there more records or not</param>
        /// <param name="serviceClient">ServiceClient</param>
        /// <returns>results as an Entity Collection or null</returns>
        public static EntityCollection GetEntityDataByFetchSearchEC(this ServiceClient serviceClient,
            string fetchXml,
            int pageCount,
            int pageNumber,
            string pageCookie,
            out string outPageCookie,
            out bool isMoreRecords,
            Guid batchId = default(Guid),
            bool bypassPluginExecution = false)
        {

            serviceClient._logEntry.ResetLastError();  // Reset Last Error

            outPageCookie = string.Empty;
            isMoreRecords = false;

            if (serviceClient.DataverseService == null)
            {
                serviceClient._logEntry.Log("Dataverse Service not initialized", TraceEventType.Error);
                return null;
            }

            if (string.IsNullOrWhiteSpace(fetchXml))
                return null;

            if (pageCount != -1)
            {
                // Add paging related parameter to fetch xml.
                fetchXml = AddPagingParametersToFetchXml(fetchXml, pageCount, pageNumber, pageCookie);
            }

            RetrieveMultipleRequest retrieve = new RetrieveMultipleRequest() { Query = new FetchExpression(fetchXml) };
            RetrieveMultipleResponse retrieved;

            if (serviceClient.AddRequestToBatch(batchId, retrieve, "Running GetEntityDataByFetchSearchEC", "Request For GetEntityDataByFetchSearchEC Queued", bypassPluginExecution))
                return null;

            retrieved = (RetrieveMultipleResponse)serviceClient.Command_Execute(retrieve, "GetEntityDataByFetchSearch", bypassPluginExecution);
            if (retrieved != null)
            {
                outPageCookie = retrieved.EntityCollection.PagingCookie;
                isMoreRecords = retrieved.EntityCollection.MoreRecords;
                return retrieved.EntityCollection;
            }

            return null;
        }


        /// <summary>
        /// Queries an Object via a M to M Link
        /// </summary>
        /// <param name="returnEntityName">Name of the entity you want return data from</param>
        /// <param name="primarySearchParameters">Search Prams for the Return Entity</param>
        /// <param name="linkedEntityName">Name of the entity you are linking too</param>
        /// <param name="linkedSearchParameters">Search Prams for the Entity you are linking too</param>
        /// <param name="linkedEntityLinkAttribName">Key field on the Entity you are linking too</param>
        /// <param name="m2MEntityName">Dataverse Name of the Relationship </param>
        /// <param name="returnEntityPrimaryId">Key field on the Entity you want to return data from</param>
        /// <param name="searchOperator">Search Operator to apply</param>
        /// <param name="batchId">Optional: if set to a valid GUID, generated by the Create Batch Request Method, will assigned the request to the batch for later execution, on fail, runs the request immediately </param>
		/// <param name="bypassPluginExecution">Adds the bypass plugin behavior to this request. Note: this will only apply if the caller has the prvBypassPlugins permission to bypass plugins.  If its attempted without the permission the request will fault.</param>
        /// <param name="fieldList">List of Fields from the Returned Entity you want</param>
        /// <param name="serviceClient">ServiceClient</param>
        /// <returns></returns>
        public static Dictionary<string, Dictionary<string, object>> GetEntityDataByLinkedSearch(this ServiceClient serviceClient,
                string returnEntityName,
                Dictionary<string, string> primarySearchParameters,
                string linkedEntityName,
                Dictionary<string, string> linkedSearchParameters,
                string linkedEntityLinkAttribName,
                string m2MEntityName,
                string returnEntityPrimaryId,
                LogicalSearchOperator searchOperator,
                List<string> fieldList,
            Guid batchId = default(Guid),
            bool bypassPluginExecution = false)
        {
            List<DataverseSearchFilter> primarySearchList = new List<DataverseSearchFilter>();
            serviceClient.BuildSearchFilterListFromSearchTerms(primarySearchParameters, primarySearchList);

            List<DataverseSearchFilter> linkedSearchList = new List<DataverseSearchFilter>();
            serviceClient.BuildSearchFilterListFromSearchTerms(linkedSearchParameters, linkedSearchList);

            return serviceClient.GetEntityDataByLinkedSearch(returnEntityName, primarySearchList, linkedEntityName, linkedSearchList, linkedEntityLinkAttribName,
                        m2MEntityName, returnEntityPrimaryId, searchOperator, fieldList, bypassPluginExecution: bypassPluginExecution);

        }

        /// <summary>
        /// Queries an Object via a M to M Link
        /// </summary>
        /// <param name="returnEntityName">Name of the entity you want return data from</param>
        /// <param name="primarySearchParameters">Search Prams for the Return Entity</param>
        /// <param name="linkedEntityName">Name of the entity you are linking too</param>
        /// <param name="linkedSearchParameters">Search Prams for the Entity you are linking too</param>
        /// <param name="linkedEntityLinkAttribName">Key field on the Entity you are linking too</param>
        /// <param name="m2MEntityName">Dataverse Name of the Relationship </param>
        /// <param name="returnEntityPrimaryId">Key field on the Entity you want to return data from</param>
        /// <param name="searchOperator">Search Operator to apply</param>
        /// <param name="batchId">Optional: if set to a valid GUID, generated by the Create Batch Request Method, will assigned the request to the batch for later execution, on fail, runs the request immediately </param>
        /// <param name="fieldList">List of Fields from the Returned Entity you want</param>
        /// <param name="bypassPluginExecution">Adds the bypass plugin behavior to this request. Note: this will only apply if the caller has the prvBypassPlugins permission to bypass plugins.  If its attempted without the permission the request will fault.</param>
        /// <param name="isReflexiveRelationship">If the relationship is defined as Entity:Entity or Account N:N Account, this parameter should be set to true</param>
        /// <param name="serviceClient">ServiceClient</param>
        /// <returns></returns>
        public static Dictionary<string, Dictionary<string, object>> GetEntityDataByLinkedSearch(this ServiceClient serviceClient,
            string returnEntityName,
            List<DataverseSearchFilter> /*Dictionary<string, string>*/ primarySearchParameters,
            string linkedEntityName,
            List<DataverseSearchFilter> /*Dictionary<string, string>*/ linkedSearchParameters,
            string linkedEntityLinkAttribName,
            string m2MEntityName,
            string returnEntityPrimaryId,
            LogicalSearchOperator searchOperator,
            List<string> fieldList,
            Guid batchId = default(Guid),
            bool isReflexiveRelationship = false,
            bool bypassPluginExecution = false)
        {
            serviceClient._logEntry.ResetLastError();  // Reset Last Error
            if (serviceClient.DataverseService == null)
            {
                serviceClient._logEntry.Log("Dataverse Service not initialized", TraceEventType.Error);
                return null;
            }

            if (primarySearchParameters == null && linkedSearchParameters == null)
                return null;

            if (primarySearchParameters == null)
                primarySearchParameters = new List<DataverseSearchFilter>(); // new Dictionary<string, string>();

            if (linkedSearchParameters == null)
                linkedSearchParameters = new List<DataverseSearchFilter>(); //new Dictionary<string, string>();



            #region Primary QueryFilter and Conditions

            FilterExpression primaryFilter = new FilterExpression();
            primaryFilter.Filters.AddRange(BuildFilterList(primarySearchParameters));

            #endregion

            #region Secondary QueryFilter and conditions

            FilterExpression linkedEntityFilter = new FilterExpression();
            linkedEntityFilter.Filters.AddRange(BuildFilterList(linkedSearchParameters));

            #endregion

            // Create Link Object for LinkedEnitty Name and add the filter info
            LinkEntity nestedLinkEntity = new LinkEntity();  // this is the Secondary
            nestedLinkEntity.LinkToEntityName = linkedEntityName; // what Entity are we linking too...
            nestedLinkEntity.LinkToAttributeName = linkedEntityLinkAttribName; // what Attrib are we linking To on that Entity
            nestedLinkEntity.LinkFromAttributeName = isReflexiveRelationship ? string.Format("{0}two", linkedEntityLinkAttribName) : linkedEntityLinkAttribName;  // what Attrib on the primary object are we linking too.
            nestedLinkEntity.LinkCriteria = linkedEntityFilter; // Filtered query

            //Create Link Object for Primary
            LinkEntity m2mLinkEntity = new LinkEntity();
            m2mLinkEntity.LinkToEntityName = m2MEntityName; // this is the M2M table
            m2mLinkEntity.LinkToAttributeName = isReflexiveRelationship ? string.Format("{0}one", returnEntityPrimaryId) : returnEntityPrimaryId; // this is the name of the other side.
            m2mLinkEntity.LinkFromAttributeName = returnEntityPrimaryId;
            m2mLinkEntity.LinkEntities.AddRange(new LinkEntity[] { nestedLinkEntity });


            // Return Cols
            // Create ColumnSet
            ColumnSet cols = null;
            if (fieldList != null && fieldList.Count > 0)
            {
                cols = new ColumnSet();
                cols.Columns.AddRange(fieldList.ToArray());
            }

            // Build Query
            QueryExpression query = new QueryExpression();
            query.NoLock = false;  // Added to remove the Locks.

            query.EntityName = returnEntityName; // Set to the requested entity Type
            if (cols != null)
                query.ColumnSet = cols;
            else
                query.ColumnSet = new ColumnSet(true);// new AllColumns();

            query.Criteria = primaryFilter;
            query.LinkEntities.AddRange(new LinkEntity[] { m2mLinkEntity });

            //Dictionary<string, Dictionary<string, object>> Results = new Dictionary<string, Dictionary<string, object>>();


            RetrieveMultipleRequest req = new RetrieveMultipleRequest();
            req.Query = query;
            RetrieveMultipleResponse retrieved;


            if (serviceClient.AddRequestToBatch(batchId, req, string.Format(CultureInfo.InvariantCulture, "Running Get Linked data, returning {0}", returnEntityName), string.Format(CultureInfo.InvariantCulture, "Request for Get Linked data, returning {0}", returnEntityName), bypassPluginExecution))
                return null;

            retrieved = (RetrieveMultipleResponse)serviceClient.Command_Execute(req, "Search On Linked Data", bypassPluginExecution);

            if (retrieved != null)
            {

                return CreateResultDataSet(retrieved.EntityCollection);
            }
            else
                return null;

        }

        /// <summary>
        /// Gets a List of variables from the account based on the list of field specified in the Fields List
        /// </summary>
        /// <param name="searchEntity">The entity to be searched.</param>
        /// <param name="entityId">ID of Entity to query </param>
        /// <param name="batchId">Optional: if set to a valid GUID, generated by the Create Batch Request Method, will assigned the request to the batch for later execution, on fail, runs the request immediately </param>
        /// <param name="bypassPluginExecution">Adds the bypass plugin behavior to this request. Note: this will only apply if the caller has the prvBypassPlugins permission to bypass plugins.  If its attempted without the permission the request will fault.</param>
        /// <param name="fieldList">Populated Array of Key value pairs with the Results of the Search</param>
        /// <param name="serviceClient">ServiceClient</param>
        /// <returns></returns>
        public static Dictionary<string, object> GetEntityDataById(this ServiceClient serviceClient, string searchEntity, Guid entityId, List<string> fieldList, Guid batchId = default(Guid), bool bypassPluginExecution = false)
        {
            serviceClient._logEntry.ResetLastError();  // Reset Last Error
            if (serviceClient.DataverseService == null || entityId == Guid.Empty)
            {
                return null;
            }

            EntityReference re = new EntityReference(searchEntity, entityId);
            if (re == null)
                return null;

            RetrieveRequest req = new RetrieveRequest();

            // Create ColumnSet
            ColumnSet cols = null;
            if (fieldList != null)
            {
                cols = new ColumnSet();
                cols.Columns.AddRange(fieldList.ToArray());
            }

            if (cols != null)
                req.ColumnSet = cols;
            else
                req.ColumnSet = new ColumnSet(true);// new AllColumns();

            req.Target = re; //getEnt;

            if (serviceClient.AddRequestToBatch(batchId, req, string.Format(CultureInfo.InvariantCulture, "Trying to Read a Record. Entity = {0} , ID = {1}", searchEntity, entityId.ToString()),
                string.Format(CultureInfo.InvariantCulture, "Request to Read a Record. Entity = {0} , ID = {1} queued", searchEntity, entityId.ToString()), bypassPluginExecution))
                return null;

            RetrieveResponse resp = (RetrieveResponse)serviceClient.Command_Execute(req, string.Format(CultureInfo.InvariantCulture, "Trying to Read a Record. Entity = {0} , ID = {1}", searchEntity, entityId.ToString()), bypassPluginExecution);
            if (resp == null)
                return null;

            if (resp.Entity == null)
                return null;

            try
            {
                // Not really doing an update here... just turning it into something I can walk.
                Dictionary<string, object> resultSet = new Dictionary<string, object>();
                AddDataToResultSet(ref resultSet, resp.Entity);
                return resultSet;
            }
            catch
            {
                return null;
            }
        }

        /// <summary>
        /// Returns all Activities Related to a given Entity ID.
        /// Only Account, Contact and Opportunity entities are supported.
        /// </summary>
        /// <param name="searchEntity">Type of Entity to search against</param>
        /// <param name="entityId">ID of the entity to search against. </param>
        /// <param name="fieldList">List of Field to return for the entity , null indicates all fields.</param>
        /// <param name="searchOperator">Search Operator to use</param>
        /// <param name="searchParameters">Filters responses based on search prams.</param>
        /// <param name="sortParameters">Sort order</param>
        /// <param name="pageCount">Number of Pages</param>
        /// <param name="pageNumber">Current Page number</param>
        /// <param name="pageCookie">inbound place holder cookie</param>
        /// <param name="outPageCookie">outbound place holder cookie</param>
        /// <param name="isMoreRecords">is there more records or not</param>
        /// <param name="batchId">Optional: if set to a valid GUID, generated by the Create Batch Request Method, will assigned the request to the batch for later execution, on fail, runs the request immediately </param>
        /// <param name="serviceClient">ServiceClient</param>
        /// <returns>Array of Activities</returns>
        public static Dictionary<string, Dictionary<string, object>> GetActivitiesBy(this ServiceClient serviceClient,
            string searchEntity,
            Guid entityId,
            List<string> fieldList,
            LogicalSearchOperator searchOperator,
            Dictionary<string, string> searchParameters,
            Dictionary<string, LogicalSortOrder> sortParameters,
            int pageCount,
            int pageNumber,
            string pageCookie,
            out string outPageCookie,
            out bool isMoreRecords,
            Guid batchId = default(Guid)
            )
        {
            List<DataverseSearchFilter> searchList = new List<DataverseSearchFilter>();
            serviceClient.BuildSearchFilterListFromSearchTerms(searchParameters, searchList);

            return serviceClient.GetEntityDataByRollup(searchEntity, entityId, "activitypointer", fieldList, searchOperator, searchList, sortParameters, pageCount, pageNumber, pageCookie, out outPageCookie, out isMoreRecords, batchId);
        }

        /// <summary>
        /// Returns all Activities Related to a given Entity ID.
        /// Only Account, Contact and Opportunity entities are supported.
        /// </summary>
        /// <param name="searchEntity">Type of Entity to search against</param>
        /// <param name="entityId">ID of the entity to search against. </param>
        /// <param name="fieldList">List of Field to return for the entity , null indicates all fields.</param>
        /// <param name="searchOperator">Search Operator to use</param>
        /// <param name="searchParameters">Filters responses based on search prams.</param>
        /// <param name="sortParameters">Sort order</param>
        /// <param name="pageCount">Number of Pages</param>
        /// <param name="pageNumber">Current Page number</param>
        /// <param name="pageCookie">inbound place holder cookie</param>
        /// <param name="outPageCookie">outbound place holder cookie</param>
        /// <param name="isMoreRecords">is there more records or not</param>
        /// <param name="batchId">Optional: if set to a valid GUID, generated by the Create Batch Request Method, will assigned the request to the batch for later execution, on fail, runs the request immediately </param>
        /// <param name="serviceClient">ServiceClient</param>
        /// <returns>Array of Activities</returns>
        public static Dictionary<string, Dictionary<string, object>> GetActivitiesBy(this ServiceClient serviceClient,
           string searchEntity,
           Guid entityId,
           List<string> fieldList,
           LogicalSearchOperator searchOperator,
           List<DataverseSearchFilter> searchParameters,
           Dictionary<string, LogicalSortOrder> sortParameters,
           int pageCount,
           int pageNumber,
           string pageCookie,
           out string outPageCookie,
           out bool isMoreRecords,
            Guid batchId = default(Guid)
           )
        {
            return serviceClient.GetEntityDataByRollup(searchEntity, entityId, "activitypointer", fieldList, searchOperator, searchParameters, sortParameters, pageCount, pageNumber, pageCookie, out outPageCookie, out isMoreRecords, batchId: batchId);
        }

        /// <summary>
        /// Returns all Activities Related to a given Entity ID.
        /// Only Account, Contact and Opportunity entities are supported.
        /// </summary>
        /// <param name="searchEntity">Type of Entity to search against</param>
        /// <param name="entityId">ID of the entity to search against. </param>
        /// <param name="fieldList">List of Field to return for the entity , null indicates all fields.</param>
        /// <param name="searchOperator"></param>
        /// <param name="searchParameters">Filters responses based on search prams.</param>
        /// <returns>Array of Activities</returns>
        /// <param name="sortParameters">Sort Order</param>
        /// <param name="batchId">Optional: if set to a valid GUID, generated by the Create Batch Request Method, will assigned the request to the batch for later execution, on fail, runs the request immediately </param>
        /// <param name="rollupfromEntity">Entity to Rollup from</param>
        /// <param name="serviceClient">ServiceClient</param>
        public static Dictionary<string, Dictionary<string, object>> GetEntityDataByRollup(this ServiceClient serviceClient,
            string searchEntity,
            Guid entityId,
            string rollupfromEntity,
            List<string> fieldList,
            LogicalSearchOperator searchOperator,
            Dictionary<string, string> searchParameters,
            Dictionary<string, LogicalSortOrder> sortParameters,
            Guid batchId = default(Guid))
        {

            List<DataverseSearchFilter> searchList = new List<DataverseSearchFilter>();
            serviceClient.BuildSearchFilterListFromSearchTerms(searchParameters, searchList);


            string pgCookie = string.Empty;
            bool moreRec = false;

            return serviceClient.GetEntityDataByRollup(
                searchEntity, entityId, rollupfromEntity, fieldList,
                searchOperator, searchList, sortParameters, -1, -1, string.Empty,
                out pgCookie, out moreRec, batchId: batchId);
        }


        /// <summary>
        /// Returns all Activities Related to a given Entity ID.
        /// Only Account, Contact and Opportunity entities are supported.
        /// </summary>
        /// <param name="searchEntity">Type of Entity to search against</param>
        /// <param name="entityId">ID of the entity to search against. </param>
        /// <param name="fieldList">List of Field to return for the entity , null indicates all fields.</param>
        /// <param name="rollupfromEntity">Entity to Rollup from</param>
        /// <param name="searchOperator">Search Operator to user</param>
        /// <param name="searchParameters">Dataverse Filter list to apply</param>
        /// <param name="sortParameters">Sort by</param>
        /// <param name="pageCount">Number of Pages</param>
        /// <param name="pageNumber">Current Page number</param>
        /// <param name="pageCookie">inbound place holder cookie</param>
        /// <param name="outPageCookie">outbound place holder cookie</param>
        /// <param name="isMoreRecords">is there more records or not</param>
        /// <param name="batchId">Optional: if set to a valid GUID, generated by the Create Batch Request Method, will assigned the request to the batch for later execution, on fail, runs the request immediately </param>
		/// <param name="bypassPluginExecution">Adds the bypass plugin behavior to this request. Note: this will only apply if the caller has the prvBypassPlugins permission to bypass plugins.  If its attempted without the permission the request will fault.</param>
        /// <param name="serviceClient">ServiceClient</param>
        /// <returns></returns>
        public static Dictionary<string, Dictionary<string, object>> GetEntityDataByRollup(this ServiceClient serviceClient,
            string searchEntity,
            Guid entityId,
            string rollupfromEntity,
            List<string> fieldList,
            LogicalSearchOperator searchOperator,
            List<DataverseSearchFilter> searchParameters,
            Dictionary<string, LogicalSortOrder> sortParameters,
            int pageCount,
            int pageNumber,
            string pageCookie,
            out string outPageCookie,
            out bool isMoreRecords,
            Guid batchId = default(Guid),
            bool bypassPluginExecution = false
            )
        {
            serviceClient._logEntry.ResetLastError();  // Reset Last Error
            outPageCookie = string.Empty;
            isMoreRecords = false;

            if (serviceClient.DataverseService == null)
            {
                serviceClient._logEntry.Log("Dataverse Service not initialized", TraceEventType.Error);
                return null;
            }

            QueryExpression query = BuildQueryFilter(rollupfromEntity, searchParameters, fieldList, searchOperator);

            if (pageCount != -1)
            {
                PagingInfo pgInfo = new PagingInfo();
                pgInfo.Count = pageCount;
                pgInfo.PageNumber = pageNumber;
                pgInfo.PagingCookie = pageCookie;
                query.PageInfo = pgInfo;

            }

            if (sortParameters != null)
                if (sortParameters.Count > 0)
                {
                    List<OrderExpression> qExpressList = new List<OrderExpression>();
                    foreach (KeyValuePair<string, LogicalSortOrder> itm in sortParameters)
                    {
                        OrderExpression ordBy = new OrderExpression();
                        ordBy.AttributeName = itm.Key;
                        if (itm.Value == LogicalSortOrder.Ascending)
                            ordBy.OrderType = OrderType.Ascending;
                        else
                            ordBy.OrderType = OrderType.Descending;

                        qExpressList.Add(ordBy);
                    }

                    query.Orders.AddRange(qExpressList.ToArray());
                }

            if (query.Orders == null)
            {
                OrderExpression ordBy = new OrderExpression();
                ordBy.AttributeName = "createdon";
                ordBy.OrderType = OrderType.Descending;
                query.Orders.AddRange(new OrderExpression[] { ordBy });
            }

            EntityReference ro = new EntityReference(searchEntity, entityId);
            if (ro == null)
                return null;

            RollupRequest req = new RollupRequest();
            req.Query = query;
            req.RollupType = RollupType.Related;
            req.Target = ro;

            if (serviceClient.AddRequestToBatch(batchId, req, string.Format(CultureInfo.InvariantCulture, "Running Get entitydatabyrollup... {0}", searchEntity), string.Format(CultureInfo.InvariantCulture, "Request for GetEntityDataByRollup on {0} queued", searchEntity), bypassPluginExecution))
                return null;

            RollupResponse resp = (RollupResponse)serviceClient.Command_Execute(req, string.Format(CultureInfo.InvariantCulture, "Locating {0} by ID in Dataverse GetActivitesBy", searchEntity), bypassPluginExecution);
            if (resp == null)
                return null;

            if ((resp.EntityCollection != null) ||
                (resp.EntityCollection.Entities != null) ||
                (resp.EntityCollection.Entities.Count > 0)
                )
            {
                isMoreRecords = resp.EntityCollection.MoreRecords;
                outPageCookie = resp.EntityCollection.PagingCookie;
                return CreateResultDataSet(resp.EntityCollection);
            }
            else
                return null;
        }

        /// <summary>
        /// This function gets data from a Dictionary object, where "string" identifies the field name, and Object contains the data,
        /// this method then attempts to cast the result to the Type requested, if it cannot be cast an empty object is returned.
        /// </summary>
        /// <param name="results">Results from the query</param>
        /// <param name="key">key name you want</param>
        /// <typeparam name="T">Type if object to return</typeparam>
        /// <param name="serviceClient">ServiceClient</param>
        /// <returns>object</returns>
        public static T GetDataByKeyFromResultsSet<T>(this ServiceClient serviceClient, Dictionary<string, object> results, string key)
        {
            try
            {
                if (results != null)
                {
                    if (results.ContainsKey(key))
                    {

                        if ((typeof(T) == typeof(int)) || (typeof(T) == typeof(string)))
                        {
                            try
                            {
                                string s = (string)results[key];
                                if (s.Contains("PICKLIST:"))
                                {
                                    try
                                    {
                                        //parse the PickList bit for what is asked for
                                        Collection<string> eleList = new Collection<string>(s.Split(':'));
                                        if (typeof(T) == typeof(int))
                                        {
                                            return (T)(object)Convert.ToInt32(eleList[1], CultureInfo.InvariantCulture);
                                        }
                                        else
                                            return (T)(object)eleList[3];
                                    }
                                    catch
                                    {
                                        // try to do the basic return
                                        return (T)results[key];
                                    }
                                }
                            }
                            catch
                            {
                                if (results[key] is T)
                                    // try to do the basic return
                                    return (T)results[key];
                            }
                        }

                        // MSB :: Added this method in light of new features in CDS 2011..
                        if (results[key] is T)
                            // try to do the basic return
                            return (T)results[key];
                        else
                        {
                            if (results != null && results.ContainsKey(key))  // Specific To CDS 2011..
                            {
                                if (results.ContainsKey(key + "_Property"))
                                {
                                    // Check for the property entry - CDS 2011 Specific
                                    KeyValuePair<string, object> property = (KeyValuePair<string, object>)results[key + "_Property"];
                                    // try to return the casted value.
                                    if (property.Value is T)
                                        return (T)property.Value;
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                serviceClient._logEntry.Log("Error In GetDataByKeyFromResultsSet (Non-Fatal)", TraceEventType.Verbose, ex);
            }
            return default(T);

        }

        #region Utilities

        /// <summary>
        /// Builds the Query expression to use with a Search.
        /// </summary>
        /// <param name="entityName"></param>
        /// <param name="searchParams"></param>
        /// <param name="fieldList"></param>
        /// <param name="searchOperator"></param>
        /// <returns></returns>
        private static QueryExpression BuildQueryFilter(string entityName, List<DataverseSearchFilter> searchParams, List<string> fieldList, LogicalSearchOperator searchOperator)
        {
            // Create ColumnSet
            ColumnSet cols = null;
            if (fieldList != null)
            {
                cols = new ColumnSet();
                cols.Columns.AddRange(fieldList.ToArray());
            }

            List<FilterExpression> filters = BuildFilterList(searchParams);

            // Link Filter.
            FilterExpression Queryfilter = new FilterExpression();
            Queryfilter.Filters.AddRange(filters);

            // Add Logical relationship.
            if (searchOperator == LogicalSearchOperator.Or)
                Queryfilter.FilterOperator = LogicalOperator.Or;
            else
                Queryfilter.FilterOperator = LogicalOperator.And;


            // Build Query
            QueryExpression query = new QueryExpression();
            query.EntityName = entityName; // Set to the requested entity Type
            if (cols != null)
                query.ColumnSet = cols;
            else
                query.ColumnSet = new ColumnSet(true);// new AllColumns();

            query.Criteria = Queryfilter;
            query.NoLock = true; // Added to remove locking on queries.
            return query;
        }

        /// <summary>
        /// Adds paging related parameter to the input fetchXml
        /// </summary>
        /// <param name="fetchXml">Input fetch Xml</param>
        /// <param name="pageCount">The number of records to be fetched</param>
        /// <param name="pageNum">The page number</param>
        /// <param name="pageCookie">Page cookie</param>
        /// <returns></returns>
        private static String AddPagingParametersToFetchXml(string fetchXml, int pageCount, int pageNum, string pageCookie)
        {
            if (String.IsNullOrWhiteSpace(fetchXml))
            {
                return fetchXml;
            }

            XmlDocument fetchdoc = XmlUtil.CreateXmlDocument(fetchXml);
            XmlElement fetchroot = fetchdoc.DocumentElement;

            XmlAttribute pageAttribute = fetchdoc.CreateAttribute("page");
            pageAttribute.Value = pageNum.ToString(CultureInfo.InvariantCulture);

            XmlAttribute countAttribute = fetchdoc.CreateAttribute("count");
            countAttribute.Value = pageCount.ToString(CultureInfo.InvariantCulture);

            XmlAttribute pagingCookieAttribute = fetchdoc.CreateAttribute("paging-cookie");
            pagingCookieAttribute.Value = pageCookie;

            fetchroot.Attributes.Append(pageAttribute);
            fetchroot.Attributes.Append(countAttribute);
            fetchroot.Attributes.Append(pagingCookieAttribute);

            return fetchdoc.DocumentElement.OuterXml;
        }

        /// <summary>
        /// Builds the Query expression to use with a Search.
        /// </summary>
        /// <param name="entityName"></param>
        /// <param name="searchParams"></param>
        /// <param name="fieldList"></param>
        /// <param name="searchOperator"></param>
        /// <param name="serviceClient">ServiceClient</param>
        /// <returns></returns>
        private static QueryExpression BuildQueryFilter(this ServiceClient serviceClient, string entityName, List<DataverseSearchFilter> searchParams, List<string> fieldList, LogicalSearchOperator searchOperator)
        {
            // Create ColumnSet
            ColumnSet cols = null;
            if (fieldList != null)
            {
                cols = new ColumnSet();
                cols.Columns.AddRange(fieldList.ToArray());
            }

            List<FilterExpression> filters = BuildFilterList(searchParams);

            // Link Filter.
            FilterExpression Queryfilter = new FilterExpression();
            Queryfilter.Filters.AddRange(filters);

            // Add Logical relationship.
            if (searchOperator == LogicalSearchOperator.Or)
                Queryfilter.FilterOperator = LogicalOperator.Or;
            else
                Queryfilter.FilterOperator = LogicalOperator.And;


            // Build Query
            QueryExpression query = new QueryExpression();
            query.EntityName = entityName; // Set to the requested entity Type
            if (cols != null)
                query.ColumnSet = cols;
            else
                query.ColumnSet = new ColumnSet(true);// new AllColumns();

            query.Criteria = Queryfilter;
            query.NoLock = true; // Added to remove locking on queries.
            return query;
        }

        /// <summary>
        /// Creates a SearchFilterList from a Search string Dictionary
        /// </summary>
        /// <param name="inSearchParams">Inbound Search Strings</param>
        /// <param name="outSearchList">List that will be populated</param>
        /// <param name="serviceClient">ServiceClient</param>
        private static void BuildSearchFilterListFromSearchTerms(this ServiceClient serviceClient, Dictionary<string, string> inSearchParams, List<DataverseSearchFilter> outSearchList)
        {
            if (inSearchParams != null)
            {
                foreach (var item in inSearchParams)
                {
                    DataverseSearchFilter f = new DataverseSearchFilter();
                    f.FilterOperator = LogicalOperator.And;
                    f.SearchConditions.Add(new DataverseFilterConditionItem()
                    {
                        FieldName = item.Key,
                        FieldValue = item.Value,
                        FieldOperator = string.IsNullOrWhiteSpace(item.Value) ? ConditionOperator.Null : item.Value.Contains("%") ? ConditionOperator.Like : ConditionOperator.Equal
                    });
                    outSearchList.Add(f);
                }
            }
        }

        /// <summary>
        /// Builds the filter list for a query
        /// </summary>
        /// <param name="searchParams"></param>
        /// <returns></returns>
        private static List<FilterExpression> BuildFilterList(List<DataverseSearchFilter> searchParams)
        {
            List<FilterExpression> filters = new List<FilterExpression>();
            // Create Conditions
            foreach (DataverseSearchFilter conditionItemList in searchParams)
            {
                FilterExpression filter = new FilterExpression();
                foreach (DataverseFilterConditionItem conditionItem in conditionItemList.SearchConditions)
                {
                    ConditionExpression condition = new ConditionExpression();
                    condition.AttributeName = conditionItem.FieldName;
                    condition.Operator = conditionItem.FieldOperator;
                    if (!(condition.Operator == ConditionOperator.NotNull || condition.Operator == ConditionOperator.Null))
                        condition.Values.Add(conditionItem.FieldValue);

                    filter.AddCondition(condition);
                }
                if (filter.Conditions.Count > 0)
                {
                    filter.FilterOperator = conditionItemList.FilterOperator;
                    filters.Add(filter);
                }
            }
            return filters;
        }

        /// <summary>
        /// Creates and Returns a Search Result Set
        /// </summary>
        /// <param name="resp"></param>
        /// <returns></returns>
        internal static Dictionary<string, Dictionary<string, object>> CreateResultDataSet(EntityCollection resp)
        {
            Dictionary<string, Dictionary<string, object>> Results = new Dictionary<string, Dictionary<string, object>>();
            foreach (Entity bEnt in resp.Entities)
            {
                // Not really doing an update here... just turning it into something I can walk.
                Dictionary<string, object> SearchRstls = new Dictionary<string, object>();
                AddDataToResultSet(ref SearchRstls, bEnt);
                // Add Ent name and ID
                SearchRstls.Add("ReturnProperty_EntityName", bEnt.LogicalName);
                SearchRstls.Add("ReturnProperty_Id ", bEnt.Id);
                Results.Add(Guid.NewGuid().ToString(), SearchRstls);
            }
            if (Results.Count > 0)
                return Results;
            else
                return null;
        }

        /// <summary>
        /// Adds data from a Entity to result set
        /// </summary>
        /// <param name="resultSet"></param>
        /// <param name="dataEntity"></param>
        private static void AddDataToResultSet(ref Dictionary<string, object> resultSet, Entity dataEntity)
        {
            if (dataEntity == null)
                return;
            if (resultSet == null)
                return;
            try
            {
                foreach (var p in dataEntity.Attributes)
                {
                    resultSet.Add(p.Key + "_Property", p);
                    resultSet.Add(p.Key, dataEntity.FormattedValues.ContainsKey(p.Key) ? dataEntity.FormattedValues[p.Key] : p.Value);
                }

            }
            catch { }
        }

        /// <summary>
        /// Lookup a entity ID by a single search element.
        /// Used for Lookup Lists.
        /// </summary>
        /// <param name="SearchValue">Text to search for</param>
        /// <param name="ent">Entity Type to Search in </param>
        /// <param name="IDField">Field that contains the id</param>
        /// <param name="SearchField">Field to Search against</param>
        /// <param name="serviceClient">ServiceClient</param>
        /// <returns>Guid of Entity or Empty Guid</returns>
        internal static Guid LookupEntitiyID(this ServiceClient serviceClient, string SearchValue, string ent, string IDField, string SearchField)
        {
            try
            {
                Guid guID = Guid.Empty;
                List<string> FieldList = new List<string>();
                FieldList.Add(IDField);

                Dictionary<string, string> SearchList = new Dictionary<string, string>();
                SearchList.Add(SearchField, SearchValue);

                Dictionary<string, Dictionary<string, object>> rslts = serviceClient.GetEntityDataBySearchParams(ent, SearchList, LogicalSearchOperator.None, FieldList);

                if (rslts != null)
                {
                    foreach (Dictionary<string, object> rsl in rslts.Values)
                    {
                        if (rsl.ContainsKey(IDField))
                        {
                            guID = (Guid)rsl[IDField];
                        }
                    }
                }
                return guID;
            }
            catch
            {
                return Guid.Empty;
            }
        }

        /// <summary>
        /// Gets the Lookup Value GUID for any given entity name
        /// </summary>
        /// <param name="entName">Entity you are looking for</param>
        /// <param name="Value">Value you are looking for</param>
        /// <param name="serviceClient">ServiceClient</param>
        /// <returns>ID of the lookup value in the entity</returns>
        internal static Guid GetLookupValueForEntity(this ServiceClient serviceClient, string entName, string Value)
        {
            // Check for existence of cached list.
            if (serviceClient._CachObject == null)
            {
                object objc = serviceClient._connectionSvc.LocalMemoryCache.Get(serviceClient._cachObjecName);
                if (objc is Dictionary<string, Dictionary<string, object>> workingObj)
                    serviceClient._CachObject = workingObj;

                if (serviceClient._CachObject == null)
                    serviceClient._CachObject = new Dictionary<string, Dictionary<string, object>>();
            }

            Guid guResultID = Guid.Empty;

            if ((serviceClient._CachObject.ContainsKey(entName.ToString())) && (serviceClient._CachObject[entName.ToString()].ContainsKey(Value)))
                return (Guid)serviceClient._CachObject[entName.ToString()][Value];

            switch (entName)
            {
                case "transactioncurrency":
                    guResultID = serviceClient.LookupEntitiyID(Value, entName, "transactioncurrencyid", "currencyname");
                    break;
                case "subject":
                    guResultID = serviceClient.LookupEntitiyID(Value, entName, "subjectid", "title"); //LookupSubjectIDForName(Value);
                    break;
                case "systemuser":
                    guResultID = serviceClient.LookupEntitiyID(Value, entName, "systemuserid", "domainname");
                    break;
                case "pricelevel":
                    guResultID = serviceClient.LookupEntitiyID(Value, entName, "pricelevelid", "name");
                    break;
                case "product":
                    guResultID = serviceClient.LookupEntitiyID(Value, entName, "productid", "productnumber");
                    break;
                case "uom":
                    guResultID = serviceClient.LookupEntitiyID(Value, entName, "uomid", "name");
                    break;
                default:
                    return Guid.Empty;
            }


            // High effort objects that are generally not changed during the live cycle of a connection are cached here.
            if (guResultID != Guid.Empty)
            {
                if (!serviceClient._CachObject.ContainsKey(entName.ToString()))
                    serviceClient._CachObject.Add(entName.ToString(), new Dictionary<string, object>());
                serviceClient._CachObject[entName.ToString()].Add(Value, guResultID);

                serviceClient._connectionSvc.LocalMemoryCache.Set(serviceClient._cachObjecName, serviceClient._CachObject, DateTime.Now.AddMinutes(5));
            }

            return guResultID;

        }

        #endregion


    }
}
