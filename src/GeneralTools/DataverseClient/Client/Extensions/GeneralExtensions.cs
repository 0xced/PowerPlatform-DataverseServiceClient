using Microsoft.Crm.Sdk.Messages;
using Microsoft.Xrm.Sdk;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;

namespace Microsoft.PowerPlatform.Dataverse.Client.Extensions
{
    /// <summary>
    /// General Extensions for the Dataverse ServiceClient
    /// </summary>
    public static class GeneralExtensions
    {
        #region Dataverse Service Methods
 
        /// <summary>
        /// Executes a named workflow on an object.
        /// </summary>
        /// <param name="workflowName">name of the workflow to run</param>
        /// <param name="id">ID to exec against</param>
        /// <param name="batchId">Optional: if set to a valid GUID, generated by the Create Batch Request Method, will assigned the request to the batch for later execution, on fail, runs the request immediately </param>
        /// <param name="bypassPluginExecution">Adds the bypass plugin behavior to this request. Note: this will only apply if the caller has the prvBypassPlugins permission to bypass plugins.  If its attempted without the permission the request will fault.</param>
        /// <param name="serviceClient">ServiceClient</param>
        /// <returns>Async Op ID of the WF or Guid.Empty</returns>
        public static Guid ExecuteWorkflowOnEntity(this ServiceClient serviceClient, string workflowName, Guid id, Guid batchId = default(Guid), bool bypassPluginExecution = false)
        {
            serviceClient._logEntry.ResetLastError();  // Reset Last Error
            if (serviceClient.DataverseService == null)
            {
                serviceClient._logEntry.Log("Dataverse Service not initialized", TraceEventType.Error);
                return Guid.Empty;
            }

            if (id == Guid.Empty)
            {
                serviceClient._logEntry.Log(string.Format(CultureInfo.InvariantCulture, "************ Exception Executing workflow ({0}) on ID {1} in Dataverse  : " + "Target Entity Was not provided", workflowName, id), TraceEventType.Error);
                return Guid.Empty;
            }

            if (string.IsNullOrEmpty(workflowName))
            {
                serviceClient._logEntry.Log(string.Format(CultureInfo.InvariantCulture, "************ Exception Executing workflow ({0}) on ID {1} in Dataverse  : " + "Workflow Name Was not provided", workflowName, id), TraceEventType.Error);
                return Guid.Empty;
            }

            Dictionary<string, string> SearchParm = new Dictionary<string, string>();
            SearchParm.Add("name", workflowName);

            Dictionary<string, Dictionary<string, object>> rslts =
                    serviceClient.GetEntityDataBySearchParams("workflow", SearchParm, LogicalSearchOperator.None, null, bypassPluginExecution: bypassPluginExecution);

            if (rslts != null)
            {
                if (rslts.Count > 0)
                {
                    foreach (Dictionary<string, object> row in rslts.Values)
                    {
                        if (serviceClient.GetDataByKeyFromResultsSet<Guid>(row, "parentworkflowid") != Guid.Empty)
                            continue;
                        Guid guWorkflowID = serviceClient.GetDataByKeyFromResultsSet<Guid>(row, "workflowid");
                        if (guWorkflowID != Guid.Empty)
                        {
                            // Ok try to exec the workflow request
                            ExecuteWorkflowRequest wfRequest = new ExecuteWorkflowRequest();
                            wfRequest.EntityId = id;
                            wfRequest.WorkflowId = guWorkflowID;

                            if (serviceClient.AddRequestToBatch(batchId, wfRequest, string.Format(CultureInfo.InvariantCulture, "Executing workflow ({0}) on ID {1}", workflowName, id),
                                string.Format(CultureInfo.InvariantCulture, "Request to Execute workflow ({0}) on ID {1} Queued", workflowName, id), bypassPluginExecution))
                                return Guid.Empty;

                            ExecuteWorkflowResponse wfResponse = (ExecuteWorkflowResponse)serviceClient.Command_Execute(wfRequest, string.Format(CultureInfo.InvariantCulture, "Executing workflow ({0}) on ID {1}", workflowName, id), bypassPluginExecution);
                            if (wfResponse != null)
                                return wfResponse.Id;
                            else
                                return Guid.Empty;
                        }
                        else
                        {
                            serviceClient._logEntry.Log(string.Format(CultureInfo.InvariantCulture, "************ Exception Executing workflow ({0}) on ID {1} in Dataverse  : " + "Unable to Find Workflow by ID", workflowName, id), TraceEventType.Error);
                        }
                    }
                }
                else
                {
                    serviceClient._logEntry.Log(string.Format(CultureInfo.InvariantCulture, "************ Exception Executing workflow ({0}) on ID {1} in Dataverse  : " + "Unable to Find Workflow by Name", workflowName, id), TraceEventType.Error);
                }
            }
            serviceClient._logEntry.Log(string.Format(CultureInfo.InvariantCulture, "************ Exception Executing workflow ({0}) on ID {1} in Dataverse  : " + "Unable to Find Workflow by Name Search", workflowName, id), TraceEventType.Error);
            return Guid.Empty;
        }
       
        /// <summary>
        /// Assign an Entity to the specified user ID
        /// </summary>
        /// <param name="userId">User ID to assign too</param>
        /// <param name="entityName">Target entity Name</param>
        /// <param name="entityId">Target entity id</param>
        /// <param name="batchId">Batch ID of to use, Optional</param>
		/// <param name="bypassPluginExecution">Adds the bypass plugin behavior to this request. Note: this will only apply if the caller has the prvBypassPlugins permission to bypass plugins.  If its attempted without the permission the request will fault.</param>
        /// <param name="serviceClient">ServiceClient</param>
        /// <returns></returns>
        public static bool AssignEntityToUser(this ServiceClient serviceClient, Guid userId, string entityName, Guid entityId, Guid batchId = default(Guid), bool bypassPluginExecution = false)
        {
            

            serviceClient._logEntry.ResetLastError();  // Reset Last Error
            if (serviceClient.DataverseService == null || userId == Guid.Empty || entityId == Guid.Empty)
            {
                return false;
            }

            AssignRequest assignRequest = new AssignRequest();
            assignRequest.Assignee = new EntityReference("systemuser", userId);
            assignRequest.Target = new EntityReference(entityName, entityId);

            if (serviceClient.AddRequestToBatch(batchId, assignRequest, string.Format(CultureInfo.InvariantCulture, "Assigning entity ({0}) to {1}", entityName, userId.ToString()),
                  string.Format(CultureInfo.InvariantCulture, "Request to Assign entity ({0}) to {1} Queued", entityName, userId.ToString()), bypassPluginExecution))
                return true;

            AssignResponse arResp = (AssignResponse)serviceClient.Command_Execute(assignRequest, "Assigning Entity to User", bypassPluginExecution);
            if (arResp != null)
                return true;

            return false;
        }

        /// <summary>
        /// This will route a Entity to a public queue,
        /// </summary>
        /// <param name="entityId">ID of the Entity to route</param>
        /// <param name="entityName">Name of the Entity that the Id describes</param>
        /// <param name="queueName">Name of the Queue to Route Too</param>
        /// <param name="workingUserId">ID of the user id to set as the working system user</param>
        /// <param name="setWorkingByUser">if true Set the worked by when doing the assign</param>
        /// <param name="batchId">Optional: if set to a valid GUID, generated by the Create Batch Request Method, will assigned the request to the batch for later execution, on fail, runs the request immediately </param>
        /// <param name="bypassPluginExecution">Adds the bypass plugin behavior to this request. Note: this will only apply if the caller has the prvBypassPlugins permission to bypass plugins.  If its attempted without the permission the request will fault.</param>
        /// <param name="serviceClient">ServiceClient</param>
        /// <returns>true on success</returns>
        public static bool AddEntityToQueue(this ServiceClient serviceClient, Guid entityId, string entityName, string queueName, Guid workingUserId, bool setWorkingByUser = false, Guid batchId = default(Guid), bool bypassPluginExecution = false)
        {
            serviceClient._logEntry.ResetLastError();  // Reset Last Error
            if (serviceClient.DataverseService == null || entityId == Guid.Empty)
            {
                return false;
            }

            Dictionary<string, string> SearchParams = new Dictionary<string, string>();
            SearchParams.Add("name", queueName);

            // Get the Target QUeue
            Dictionary<string, Dictionary<string, object>> rslts = serviceClient.GetEntityDataBySearchParams("queue", SearchParams, LogicalSearchOperator.None, null);
            if (rslts != null)
                if (rslts.Count > 0)
                {
                    Guid guQueueID = Guid.Empty;
                    foreach (Dictionary<string, object> row in rslts.Values)
                    {
                        // got something
                        guQueueID = serviceClient.GetDataByKeyFromResultsSet<Guid>(row, "queueid");
                        break;
                    }

                    if (guQueueID != Guid.Empty)
                    {


                        AddToQueueRequest req = new AddToQueueRequest();
                        req.DestinationQueueId = guQueueID;
                        req.Target = new EntityReference(entityName, entityId);

                        // Set the worked by user if the request includes it.
                        if (setWorkingByUser)
                        {
                            Entity queItm = new Entity("queueitem");
                            queItm.Attributes.Add("workerid", new EntityReference("systemuser", workingUserId));
                            req.QueueItemProperties = queItm;
                        }

                        if (serviceClient.AddRequestToBatch(batchId, req, string.Format(CultureInfo.InvariantCulture, "Assigning entity to queue ({0}) to {1}", entityName, guQueueID.ToString()),
                                    string.Format(CultureInfo.InvariantCulture, "Request to Assign entity to queue ({0}) to {1} Queued", entityName, guQueueID.ToString()), bypassPluginExecution))
                            return true;

                        AddToQueueResponse resp = (AddToQueueResponse)serviceClient.Command_Execute(req, string.Format(CultureInfo.InvariantCulture, "Adding a item to queue {0} in CDS", queueName), bypassPluginExecution);
                        if (resp != null)
                            return true;
                        else
                            return false;
                    }
                }
            return false;
        }

        /// <summary>
        /// this will send an Email to the
        /// </summary>
        /// <param name="emailid">ID of the Email activity</param>
        /// <param name="token">Tracking Token or Null</param>
        /// <param name="batchId">Optional: if set to a valid GUID, generated by the Create Batch Request Method, will assigned the request to the batch for later execution, on fail, runs the request immediately </param>
		/// <param name="bypassPluginExecution">Adds the bypass plugin behavior to this request. Note: this will only apply if the caller has the prvBypassPlugins permission to bypass plugins.  If its attempted without the permission the request will fault.</param>
        /// <param name="serviceClient">ServiceClient</param>
        /// <returns></returns>
        public static bool SendSingleEmail(this ServiceClient serviceClient, Guid emailid, string token, Guid batchId = default(Guid), bool bypassPluginExecution = false)
        {
            serviceClient._logEntry.ResetLastError();  // Reset Last Error
            if (serviceClient.DataverseService == null || emailid == Guid.Empty)
            {
                return false;
            }

            if (token == null)
                token = string.Empty;

            // Send the mail now.
            SendEmailRequest req = new SendEmailRequest();
            req.EmailId = emailid;
            req.TrackingToken = token;
            req.IssueSend = true; // Send it now.

            if (serviceClient.AddRequestToBatch(batchId, req, string.Format(CultureInfo.InvariantCulture, "Send Direct email ({0}) tracking token {1}", emailid.ToString(), token),
                    string.Format(CultureInfo.InvariantCulture, "Request to Send Direct email ({0}) tracking token {1} Queued", emailid.ToString(), token), bypassPluginExecution))
                return true;

            SendEmailResponse sendresp = (SendEmailResponse)serviceClient.Command_Execute(req, string.Format(CultureInfo.InvariantCulture, "Sending email ({0}) from Dataverse", emailid), bypassPluginExecution);
            if (sendresp != null)
                return true;
            else
                return false;
        }

        /// <summary>
        /// Returns the user ID of the currently logged in user.
        /// </summary>
        /// <param name="serviceClient">ServiceClient</param>
        /// <returns></returns>
        public static Guid GetMyUserId(this ServiceClient serviceClient)
        {
            return serviceClient.SystemUser.UserId;
        }

        #endregion
    }
}
